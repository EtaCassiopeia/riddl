# riddl
[![pipeline](https://gitlab.com/yoppworks/ossum/riddl/badges/master/pipeline.svg)](https://gitlab.com/yoppworks/ossum/riddl/-/commits/master)
[![coverage](https://gitlab.com/yoppworks/ossum/riddl/badges/master/coverage.svg)](https://gitlab.com/yoppworks/ossum/riddl/-/commits/master)

## Introduction
RIDDL, the Reactive Interface to Domain Definition Language, is a tool for
eliminating the boilerplate from reactive systems designed with Domain
Driven Design (DDD).   
It uses a DDD and UML inspired specification language to allow developers to 
work at a higher level of specification than they would if they
were coding directly in a programming language. It aims to relieve developers
of the burden of maintaining infrastructural code through evolution of the
domain abstractions.

RIDDL is one of the Ossum tools. Ossum is a collection of tools for making
awesome reactive systems.

For more details, please read the paradox documentation:

* `sbt paradox`
* `open riddlc/target/paradox/html/main/index.html`

## Usage
To get the most recent options, run `riddlc --help`. As of version 0.1.1, that 
will print out:
```text
RIDDL Compiler (c) 2019 Yoppworks Inc. All rights reserved. 
Version:  0.1.1
Usage: riddlc [parse|prettify|validate|translate] [options]

  -h, --help
  -v, --verbose
  -q, --quiet
  -w, --suppress-warnings
  -m, --suppress-missing-warnings
  -s, --suppress-style-warnings
  -t, --show-times
Command: parse [options]
Parse the input for syntactic compliance with riddl language
  -i, --input-file <value>
                           required riddl input file to compile
Command: prettify [options]
Parse the input and print it out in prettified style
  -i, --input-file <value>
                           required riddl input file to compile
Command: validate [options]

  -i, --input-file <value>
                           required riddl input file to compile
Command: translate [options]
translate riddl as specified in configuration file 
  -i, --input-file <value>
                           required riddl input file to compile
  -c, --configuration-file <value>
                           configuration that specifies how to do the translation
``` 
## Goals
This project is currently nascent. It doesn't do anything yet, but eventually
we hope it will do all of the following:

* Generate Swagger (OpenAPI) YAML files containing API documentation for 
 REST APIs
* Generate Lagom based microservices to implement bounded contexts
* Generate Cloudstate.io based microservices to implement bounded contexts
* Generate Akka/HTTP server stubs
* Generate Akka/HTTP client library
* Generate Kafka server stubs
* Generate Kafka client library
* Generate Scala.JS based browser client side
* Generate graphQL based on domain model  
* Supporting a SaaS system for the generation of the above items working
 something like https://www.websequencediagrams.com/ by allowing direct
  typing and immediate feedback   
* Serve as the de facto (or real) standard for defining business domains and
  reactive systems.
* Be designed to be used with event storming
* Designed for a fully reactive implementation with messaging between
  contexts
* Support pluggable code generators for targeting different execution
 environments.
* Potential executors:  Akka Data Pipelines, Akka Serverless, Akka/Scala
* Incorporate the best interface language ideas from CORBA, Reactive
 Architecture, DDD, REST, DCOM, gRPC, etc. 
* Support for Read Projections and Read Models (plugins for databases)
* Support for graphQL and gRPC

## Dependencies

This codebase targets Java 17 and Scala 2.14.7 with -XSource:3 in preparation for 
Scala 3.0 code conversion. 

## Generating Documentation
Documentation is now generated by sbt-site and its HugoPlugin for sbt.  However,
to read and write documentation it is generally better to work directly with hugo.
You need to make sure Hugo is installed:
```shell
brew install hugo  
```
Then run the hugo server:
```shell
cd doc/src/hugo
hugo server --disableFastRender -D
```
The hugo server command will ensure that writes to the source files will cause
the server to eject built pages from memory cache and rebuild them from the
source the next time they are requested. To view the site in your browser:
```shell
open http://localhost:1313/
```
