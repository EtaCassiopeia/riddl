// #everything
// #domains
domain ReactiveBBQ {
// #domains

  // Create some types with better names than just "Id"
  type CustomerId is Id explained as {
    "Unique identifier for a customer"
  }
  type OrderId is Id explained as {
    "Unique identifier for a customer's order"
  }

  // #Kitchen
  // The Kitchen context pertains to
  context Kitchen {
    type IP4Address is combine { a: Number, b: Number, c: Number, d: Number}
    type OrderViewType is combine {
      address is IP4Address
    }
    entity OrderViewer is OrderViewType {
      option is device
    } explained as {
      "The OrderViewer is the device in the kitchen, probably a touch screen,"
      "that the cooks use to view the sequence of orders to cook"
    }
  } explained as {
    "The kitchen bounded context provides the ability for the kitchen staff"
    "to interact with orders they are preparing. The kitchen is a client of"
    "the orders bounded context and interacts with that context alone"
    "the outstanding orders to be prepared. Everything else that happens in"
    "the kitchen is out of scope for the restaurant automation software. "
    "Consequently, this bounded context is pretty minimal."
    "### Subject-Verb-Object Statements"
    "1. Kitchen displays orders"
    "1. Order is sent to Kitchen for display"
    "2. Order sends order status changes to Kitchen"
    "2. Kitchen ignores drink items on order"
    "1. "
  }
  // #Kitchen

  // #Loyalty
  context Loyalty {
    type AccrualEvent is combine {
      when is TimeStamp,
      who is CustomerId,
      pointsAccrued is Number,
      fromOrder is OrderId
    }
    type AwardEvent is combine {
      when is TimeStamp,
      who is CustomerId,
      pointsAwarded is Number,
      toOrder is OrderId
    }
    type RewardEvent is choose { AccrualEvent or AwardEvent }
    type RewardsAccountType is combine {
      id is CustomerId,
      points is Number,
      rewardEvents is RewardEvent*
    }
    entity RewardsAccount is RewardsAccountType {
    }
  }
  // #Loyalty

  // #Order
  context Order {
    type OrderType is combine {
      orderId is OrderId,
      customerId is CustomerId
    }
    entity Order is OrderType {
      option is aggregate
    }
  }
  // #Order

  // #Payment
  context Payment {
    type PaymentType is combine {
      orderId is Id,
      amount is Number,
      cardToken is String
    }
    entity Payment is PaymentType {
      option is aggregate
    }
  }
  // #Payment

  // #Menu
  context Menu {
    entity MenuItem is String {
    }
    entity Menu is MenuItem+ {
      option is aggregate
    }
  }
  // #Menu

  // #Reservation
  context Reservation {
    type ReservationValue is combine {
      partyName is String,
      phoneNumber is String,
      location is Id,
      time is Time,
      date is Date
    }

    entity Reservation is ReservationValue {
      consumes channel foo
      produces channel bar
    }
  }
  // #Reservation
} explained as {
  "# Reactive BBQ Domain Definition"
  "This domain definition is designed to be instructive in the RIDDL language."
  "It uses the case study from the Lightbend Reactive Architecture course as"
  "the basis for defining the domain. The course uses a set of interviews with"
  "Reactive BBQ employees to define the requirements. This domain specification"
  "is a possible result of analyzing that domain: the Reactive BBQ restaurant."
}
// #everything
